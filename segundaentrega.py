# -*- coding: utf-8 -*-
"""SegundaEntrega.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_AVtBHrKZxHOjeuijsL1hfjIqlWhpiQS

# Clasificador Frutas Segunda aproximacion al codigo Aproximaciones Al Codigo
## Tecnicas IA
### Universidad Nacional de Colonbia

1.   Daniel Andres Rojas Paredes
2.   Luis Alberto Chavez Castro



#### 2022-2
"""

# Librerías
import numpy as np
import cv2
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import scipy.ndimage.morphology as m
import glob
import PIL
#import scipy.misc
from scipy.signal import convolve2d as conv2
from skimage import data, io, filters
from skimage.morphology import skeletonize
from skimage.filters import threshold_multiotsu as mot

"""##### Matplotlib:Libreria de trazado de graficos 2d al usar el modul pyplot se pueden usar graficas con configuraciones similares a las de matlab el manejo de matricez lo hace en el formato Numpy
##### Numpy: Permite todo el calculo de matricez
##### PIL:Libreria de manejo y procesamiento de imagenes El módulo Imagen proporciona una clase con el mismo nombre que se utiliza para representar una imagen PIL. El módulo también proporciona una serie de funciones de fábrica, incluidas funciones para cargar imágenes desde archivos y para crear nuevas imágenes.
##### Scipy: ofrece un entorno similar al de matlab y a travez del paquete ndimage.morphology se pueden realizar operaciones de erocion dilatacion y demas operaciones morfologicas en imagenes ndimencionales , con el modulo signal  se pueden realizar diferentes operaciones del procesamiento de señales basico
#####Skimage: es un conjunto de algorithmos para el procesamiento de imagen el modulo de filtros posee operaciones como Nitidez, búsqueda de bordes, filtros de rango, umbralización, etc. el de io  permite Leer, guardar y mostrar imágenes y videos. y el modulo data tiene ejemplos y testeos

####Libreria Glob se usa para especificar los paths atravez de la funcion glob puedo obtener una lista d todos los archivos de donde se ejecuta el kernel espesificando un comando espesifico de manera muy similar a como se aria en linux

"""

from google.colab import drive
drive.mount('/content/drive')

"""**Importo librerias de pythoch e instancio RED NEURONAL**"""

import torch
import torch.nn as nn
import torch.nn.functional as F #capas sin parametros

#una red se monta como una clase que hereda de nn.module
# en el metdo init como atributos van todas las capas con pareametros que deben ser entrenadas
# en el metodo fordware van todas las capas
class Net(nn.Module):
  def __init__(self, num_channels):
    super(Net,self).__init__()

    self.num_channels = num_channels

    self.conv1 = nn.Conv2d(3, self.num_channels, 3, stride = 1, padding = 1)
    self.conv2 = nn.Conv2d(self.num_channels, self.num_channels*2, 3, stride = 1, padding = 1)
    self.conv3 = nn.Conv2d(self.num_channels*2, self.num_channels*4, 3, stride = 1, padding = 1)

    self.fc1 = nn.Linear(self.num_channels*4*32*32, self.num_channels*4)
    self.fc2 = nn.Linear(self.num_channels*4, 3)

  def forward(self,x):
      #Empieza 3x512x512
      x = self.conv1(x) # num_channels x 512x512
      x = F.relu(F.max_pool2d(x, 2)) # num_channels x 256x256
      x = self.conv2(x) # num_channels*2 x 256x256
      x = F.relu(F.max_pool2d(x, 2)) #num_channels*2 x 128x128
      x = self.conv3(x) # num_channels*4 x128x128
      x = F.relu(F.max_pool2d(x, 2)) # num_channels*4 x 64x64

      #flatten
      x = x.view(-1, self.num_channels*4*32*32)

      #fc
      x = self.fc1(x)
      x = F.relu(x)
      x = self.fc2(x)

      #log_softmax

      x = F.log_softmax(x, dim=1)

      return x

"""**Carga Dataset Resize de las imagenes**"""

MainDir="/content/drive/Shareddrives/TIA/DATASET/Training/"
import os
from PIL import Image
from torch.utils.data import Dataset, DataLoader
from torchvision.datasets import ImageFolder
import torchvision.transforms  as transforms
from torchvision.utils import make_grid
from torch.utils.data import random_split
from torchvision.transforms import Resize

"""Conjunto de entrenamiento: se utiliza para entrenar el modelo, es decir, calcular la pérdida y ajustar los pesos del modelo mediante descenso de gradiente.
Conjunto de validación: se utiliza para evaluar el modelo durante el entrenamiento, ajustar los hiperparámetros (tasa de aprendizaje, etc.) y elegir la mejor versión del modelo.
Conjunto de prueba: se utiliza para comparar diferentes modelos o diferentes tipos de enfoques de modelado e informar la precisión final del modelo. Dado que no hay un conjunto de validación predefinido, podemos reservar una pequeña parte (alrededor del 10% del conjunto de datos de entrenamiento) para usar como conjunto de validación. Usaremos el método auxiliar random_split de PyTorch para hacer esto. Para asegurarnos de crear siempre el mismo conjunto de validación, también estableceremos una semilla para el generador de números aleatorios
"""

# SE AJUSTA LAS IMAGENES A UN MISMO TAMAÑO TODAS PARA PODER TRA
#KEAR EL TAMAÑO DEL TENSOR ESTO TAMBIEN FUNCIONA COMO REGULARIZACION EN CUANTO SE AUM
#MENTA LA CANTIDAD DE NEURONAS?
settingData =transforms.Compose ([
    transforms.Resize((256,256)),
    transforms.ToTensor(),
    transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5)),# Normalizacion
    ])
Data = ImageFolder(MainDir + '/Tangerinne', transform=settingData)
print('Size of training dataset :', len(Data))

# view one image shape of the dataset.
img, label = Data[5]
print(img.shape)
print(label)
plt.imshow(img.permute(1, 2, 0))

#DATALOADERS
validation,test,train=torch.utils.data.random_split(Data, [40, 40,len(Data)-80], generator=torch.Generator( ).manual_seed(42))
batch_size = 32
train_loader = DataLoader(train, batch_size, shuffle=True, num_workers=4, pin_memory=True)
test_loader = DataLoader(test, batch_size, num_workers=4, pin_memory=True)
Validation_loader = DataLoader(validation, batch_size, num_workers=4, pin_memory=True)
loaders = {'train':train_loader,'test':test_loader,'val':Validation_loader}

from torchvision.utils import make_grid
grid=0
for inputs, targets in Validation_loader:
  grid = make_grid(inputs)
  print(targets)
  break
img = transforms.ToPILImage()(grid)

plt.imshow(img)

"""**OPTIMIZACION y definicion de metricas**

"""

##INSTANCIO CLASE DE METRICAS
#ETA FUNCION CORRE LOS 3 METODOS XADA QUE ES LLAMADA?
#HACE IN PROMEDIO DE s
class RunningMetric():
  def __init__(self):
    self.S = 0
    self.N = 0

  def update(self, val, size):
    self.S += val
    self.N += size

  def __call__(self):
    return self.S/float(self.N)

import torch.optim as optim
from torch.utils.tensorboard import SummaryWriter
from datetime import datetime
device = torch.device('cuda')
device

"""Que es y quehace un optimizador.

El learning rates solia ser escogido a mano , sin embargo este proceso es bastante tedioso, asi que se han desarrollado algorithmos para la escogencia de este learning rate  llamados optimisadores adaptativos (adagrad, adadelta,adam) que estan basados en el Stochastic gradient desent.  que es el optiizador que usaremos
"""

net = Net(32).to(device)

loss_fn = nn.NLLLoss()
optimizer = optim.SGD(net.parameters(), lr=1e-3, momentum = 0.9)

"""**GRAFICADORES DE METRICAS**

EPOCHS LOPOP DE ENTRENAMIENTO
"""

num_epochs = 50
timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
writer = SummaryWriter('runs/Bannanas_trainer_{}'.format(timestamp),flush_secs=120)

for epoch in range(num_epochs):
 # print('Epoch {}/{}'.format(epoch+1, num_epochs))
  #print('-'*10)

  running_loss = RunningMetric() # perdida
  running_acc = RunningMetric() #precision

  for inputs, targets in train_loader:
    inputs, targets = inputs.to(device), targets.to(device)
    #Calcular los gradienes de la funcion de costo respecto a los paramentros
    #actualizar los parametros con dichos gradientes
    #pytorch acumula el gradiente, no es deseado, debe ser reiniciado en 0
    optimizer.zero_grad()

    outputs = net(inputs)#  batch.size filas por 3 columnas
    _, preds = torch.max(outputs,1) #para cada fila devuelve el maximo de las columnas
    #preds se refiere al indice de ese valor
    loss = loss_fn(outputs, targets)

    loss.backward() #back propagation
    optimizer.step() #learning rate con S gradient desent

    batch_size = inputs.size()[0]
    running_loss.update(loss.item()*batch_size,
                       batch_size) #se actualiza el promedio ponderado de la perdida segun el batch
    running_acc.update(torch.sum(preds == targets).float(), #De los 32 cuantos predijo bien
                       batch_size)
    writer.add_scalar('Loss/train', running_loss(), num_epochs)
    writer.add_scalar('accus/train',running_acc(), num_epochs)
  print("Loss: {:.4f} Acc: {:.4f} ".format(running_loss(),
                                          running_acc()))

from tensorboard import notebook
notebook.list() # View open TensorBoard instances
notebook.display(port=6006, height=1000)



#plot_losses(loss_history)
#plot_accuracies(acu_history)

"""**REGULARIZACIÓN**

"""

#aumentar el dataset virtualmente y normalizar con campana gauciana
Regularizacion =transforms.Compose ([
        transforms.RandomHorizontalFlip,#aumentation
        transforms.ToTensor(),
        transforms.Normalize((0.5,0.5,0.5),(0.5,0.5,0.5)),# Normalizacion
    ])

#una red se monta como una clase que hereda de nn.module
# en el metdo init como atributos van todas las capas con pareametros que deben ser entrenadas
# en el metodo fordware van todas las capas
class Net(nn.Module):
  def __init__(self, num_channels):
    super(Net,self).__init__()

    self.num_channels = num_channels

    self.conv1 = nn.Conv2d(3, self.num_channels, 3, stride = 1, padding = 1)
    self.bn1=nn.BatchNorm2d(self.num_channels)# batch normalization para cada capa de la red
    self.conv2 = nn.Conv2d(self.num_channels, self.num_channels*2, 3, stride = 1, padding = 1)
    self.bn2=nn.BatchNorm2d(self.num_channels*2)
    self.conv3 = nn.Conv2d(self.num_channels*2, self.num_channels*4, 3, stride = 1, padding = 1)
    self.bn3=nn.BatchNorm2d(self.num_channels*4)

    self.fc1 = nn.Linear(self.num_channels*4*32*32, self.num_channels*4)
    self.fcbn1=nn.BatchNorm1d(self.num_channels*4)# es 1d porque aca el tensor es un arreglo no una imagen se aplano
    self.fc2 = nn.Linear(self.num_channels*4, 3)

  def forward(self,x):
      #Empieza 3x512x512
      x = self.bn1(self.conv1(x)) # num_channels x 512x512
      x = F.relu(F.max_pool2d(x, 2)) # num_channels x 256x256
      x = self.bn2(self.conv2(x)) # num_channels*2 x 256x256
      x = F.relu(F.max_pool2d(x, 2)) #num_channels*2 x 128x128
      x = self.bn3(self.conv3(x)) # num_channels*4 x128x128
      x = F.relu(F.max_pool2d(x, 2)) # num_channels*4 x 64x64

      #flatten
      x = x.view(-1, self.num_channels*4*32*32)##????

      #fc
      x = F.relu(self.fcbn1(self.fc1(x)))
      x = F.dropout(x,p=0.8,training=True)#Dropout
      x = self.fc2(x)

      #log_softmax

      x = F.log_softmax(x, dim=1)

      return x

"""OPTIMIZACION DE HIPERPARAMETROS  POR RANDOM SEARCH SI AY TIEMPO SI NO POR LA GERARQUIA DE ANDREW NG"""

historial_training=[]
historial_val=[]

def T_and_E(model,optimizer,loss_fn,dataloader,device,num_epochs=10,lr=0.0001):
  for g in optimizer.param_groups:
    g['lr']=lr
    print("lrs{} : ".format(lr))
  for epoch in range(num_epochs):
    #print('Epoch {}/{}'.format(epoch+1, num_epochs))
    #print('-'*10)

    for phase in ['train','val']:
      if phase == 'train':
        model.train()
      else:
        model.eval()
      running_loss = RunningMetric() # perdida
      running_acc = RunningMetric() #precision

      for inputs, targets in loaders[phase]:
        inputs, targets = inputs.to(device), targets.to(device)
        optimizer.zero_grad()
        with torch.set_grad_enabled(phase=='train'):
          #calculo la perdida
          outputs = net(inputs)
          _, preds = torch.max(outputs,1)
          loss = loss_fn(outputs, targets)
          if phase=='train':

            loss.backward() #back propagation
            optimizer.step() #learning rate con S gradient desent

        batch_size = inputs.size()[0]
        running_loss.update(loss.item()*batch_size,
                          batch_size)
        running_acc.update(torch.sum(preds == targets).float(),
                          batch_size)
     # print("Loss: {:.4f} Acc: {:.4f} ".format(running_loss(),
             #                                 running_acc()))
      print("Loss{}: {:.4f} Acc{}: {:.4f} ".format(phase,
      running_loss(),
      phase,
      running_acc()))
  return model

net = Net(32).to(device)
loss_fn = nn.NLLLoss()
optimizer = optim.SGD(net.parameters(), lr=1e-3, momentum = 0.9)
num_epochs = 10

"""segmentacion"""

T_and_E (net,optimizer,loss_fn,loaders,device,num_epochs,1e-6)

import random

lrs=[10**(-4),10**(-5),10**(-6)]#10**(-random.randint(4,6))for _ in range(3)
for lr in lrs :
  T_and_E (net,optimizer,loss_fn,loaders,device,num_epochs,lr)

T_and_E (net,optimizer,loss_fn,loaders,device,num_epochs,1e-5)

b=T_and_E (netb,optimizer,loss_fn,loaders,device,num_epochs,1e-07)



"""### metodo predict para validacion

---https://interactivechaos.com/es/manual/tutorial-de-deep-learning/cuerpo-del-metodo-predict

TensorBoard
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install tensorboard

# Commented out IPython magic to ensure Python compatibility.
# %pylab inline
import torch.utils.tensorboard as tb
import tempfile
log_dir=tempfile.mkdtemp()#directorio para guardar logs
#%tensorboard --logdir(log_dir) --reload_interval 1 #reload every 1scd
# al parecer ya no
# %load_ext tensorboard
# %tensorboard --logdir {logs_base_dir}

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir=runs



"""redes convolucionales"""